import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react'
import { Box, Typography, Card, CardContent, Button, Dialog, DialogTitle, DialogContent, DialogActions, TextField, Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Paper, Chip, IconButton, Grid, CircularProgress, Alert, Snackbar, Autocomplete, FormControl, InputLabel, Select, MenuItem as MuiMenuItem, Divider, List, ListItem, ListItemText, ListItemSecondaryAction, Fab, Stack, useTheme, TableSortLabel, Collapse, CardActionArea } from '@mui/material'
import { Add as AddIcon, Edit as EditIcon, Delete as DeleteIcon, ShoppingCart as OrderIcon, LocalShipping as DeliveryIcon, Schedule as ScheduleIcon, AutoMode as AutoOrderIcon, Warning as WarningIcon, Check as CheckIcon, ExpandMore as ExpandMoreIcon, ExpandLess as ExpandLessIcon, Search as SearchIcon, Upload as UploadIcon } from '@mui/icons-material'
import { format } from 'date-fns'
import { SupplierOrder, SupplierOrderItem, Supplier, Ingredient } from '../types'
import { supplierOrdersService, suppliersService, ingredientsService, subscriptions } from '../services/supabaseService'
import { nomNomColors } from '../theme/nomnom-theme'
import { useTranslation } from 'react-i18next'
import Papa from 'papaparse'
import { formatCurrency } from '../utils/currency'

const ORDER_STATUSES = ['draft', 'submitted', 'confirmed', 'shipped', 'delivered', 'cancelled'] as const
const ORDER_PRIORITIES = ['low', 'medium', 'high', 'urgent'] as const

const getStatusColor = (status: SupplierOrder['status']) => {
  switch (status) {
    case 'draft':
      return 'default'
    case 'submitted':
      return 'info'
    case 'confirmed':
      return 'primary'
    case 'shipped':
      return 'warning'
    case 'delivered':
      return 'success'
    case 'cancelled':
      return 'error'
    default:
      return 'default'
  }
}

const getPriorityColor = (priority: SupplierOrder['priority']) => {
  switch (priority) {
    case 'low':
      return 'default'
    case 'medium':
      return 'info'
    case 'high':
      return 'warning'
    case 'urgent':
      return 'error'
    default:
      return 'default'
  }
}

export default function SupplierOrders() {
  const theme = useTheme()
  const docDir = typeof document !== 'undefined' ? document.documentElement.dir : undefined
  const isRtl = docDir === 'rtl' || theme.direction === 'rtl'
  const { t } = useTranslation()
  const [openDialog, setOpenDialog] = useState(false)
  const [editingOrder, setEditingOrder] = useState<SupplierOrder | null>(null)
  const [orders, setOrders] = useState<SupplierOrder[]>([])
  const [suppliers, setSuppliers] = useState<Supplier[]>([])
  const [ingredients, setIngredients] = useState<Ingredient[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'success' as 'success' | 'error' | 'warning' })

  const [newOrder, setNewOrder] = useState<Partial<SupplierOrder>>({
    supplierId: '',
    items: [],
    totalAmount: 0,
    status: 'draft',
    priority: 'medium',
    orderDate: new Date(),
    autoGenerated: false,
    notes: ''
  })

  // Sorting state
  type OrderBy = 'orderNumber' | 'supplier' | 'totalAmount' | 'status' | 'priority' | 'orderDate' | 'expectedDeliveryDate'
  const [orderBy, setOrderBy] = useState<OrderBy>('orderDate')
  const [orderDirection, setOrderDirection] = useState<'asc' | 'desc'>('desc')

  // Collapse state for suppliers without open orders
  const [expandedSuppliersSection, setExpandedSuppliersSection] = useState(false)

  // Search state
  const [searchQuery, setSearchQuery] = useState('')

  // Import state
  const [openImportDialog, setOpenImportDialog] = useState(false)
  const [importData, setImportData] = useState<any[]>([])
  const [importMapping, setImportMapping] = useState<{
    supplier?: Supplier
    itemNameColumn?: string
    quantityColumn?: string
    unitPriceColumn?: string
  }>({})
  const fileInputRef = useRef<HTMLInputElement>(null)

  // Use interface with stable ID for order items
  interface OrderItemWithId extends SupplierOrderItem {
    tempId: string
  }

  const [orderItems, setOrderItems] = useState<OrderItemWithId[]>([])

  // Load data on component mount
  useEffect(() => {
    loadOrders()
    loadSuppliers()
    loadIngredients()
  }, [])

  // Set up real-time subscription
  useEffect(() => {
    const subscription = subscriptions.supplierOrders(payload => {
      console.log('Supplier orders changed:', payload)
      loadOrders()
    })

    return () => {
      subscription.unsubscribe()
    }
  }, [])

  const loadOrders = async () => {
    try {
      setLoading(true)
      setError(null)
      const data = await supplierOrdersService.getAll()
      setOrders(data)
    } catch (err) {
      setError(err instanceof Error ? err.message : t('failed_to_load_data'))
    } finally {
      setLoading(false)
    }
  }

  const loadSuppliers = async () => {
    try {
      const data = await suppliersService.getAll()
      setSuppliers(data.filter(s => s.isActive))
    } catch (err) {
      console.error('Failed to load suppliers:', err)
    }
  }

  const loadIngredients = async () => {
    try {
      const data = await ingredientsService.getAll()
      console.log('Loaded ingredients with packaging info:', data)
      setIngredients(data.filter(i => i.isAvailable))
    } catch (err) {
      console.error('Failed to load ingredients:', err)
    }
  }

  const handleOpenDialog = (order?: SupplierOrder) => {
    if (order) {
      setEditingOrder(order)
      setNewOrder(order)
      setOrderItems(
        order.items.map(item => ({
          ...item,
          tempId: `temp-${Date.now()}-${Math.random()}`
        }))
      )
    } else {
      setEditingOrder(null)
      setNewOrder({
        supplierId: '',
        items: [],
        totalAmount: 0,
        status: 'draft',
        priority: 'medium',
        orderDate: new Date(),
        autoGenerated: false,
        notes: ''
      })
      setOrderItems([])
    }
    setOpenDialog(true)
  }

  const handleCloseDialog = () => {
    setOpenDialog(false)
    setEditingOrder(null)
    setOrderItems([])
  }

  // Import functions
  const handleImportClick = () => {
    fileInputRef.current?.click()
  }

  const handleFileImport = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (!file) return

    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: results => {
        setImportData(results.data)
        setOpenImportDialog(true)
      },
      error: error => {
        setSnackbar({
          open: true,
          message: t('failed_to_parse_file') + ': ' + error.message,
          severity: 'error'
        })
      }
    })

    // Reset file input
    event.target.value = ''
  }

  const handleImportMapping = async () => {
    if (!importMapping.supplier || !importMapping.itemNameColumn || !importMapping.quantityColumn || !importMapping.unitPriceColumn) {
      setSnackbar({ open: true, message: t('please_map_all_required_fields'), severity: 'warning' })
      return
    }

    try {
      // Map imported data to order items
      const mappedItems: OrderItemWithId[] = []

      for (const row of importData) {
        const itemName = row[importMapping.itemNameColumn]?.toString().trim()
        const quantity = parseFloat(row[importMapping.quantityColumn] || 0)
        const unitPrice = parseFloat(row[importMapping.unitPriceColumn] || 0)

        if (!itemName || quantity <= 0) continue

        // Try to match with existing ingredients
        const matchedIngredient = ingredients.find(ing => ing.name.toLowerCase() === itemName.toLowerCase() && ing.supplier === importMapping.supplier?.name)

        if (matchedIngredient) {
          mappedItems.push({
            tempId: `temp-${Date.now()}-${Math.random()}`,
            ingredientId: matchedIngredient.id,
            quantity: quantity,
            unitPrice: unitPrice || matchedIngredient.costPerUnit,
            totalPrice: quantity * (unitPrice || matchedIngredient.costPerUnit)
          })
        }
      }

      if (mappedItems.length === 0) {
        setSnackbar({ open: true, message: t('no_matching_ingredients_found'), severity: 'warning' })
        return
      }

      // Create new order with imported items
      setNewOrder({
        supplierId: importMapping.supplier.id,
        items: [],
        totalAmount: 0,
        status: 'draft',
        priority: 'medium',
        orderDate: new Date(),
        autoGenerated: false,
        notes: t('imported_from_file')
      })
      setOrderItems(mappedItems)
      setOpenImportDialog(false)
      setOpenDialog(true)

      setSnackbar({
        open: true,
        message: t('successfully_imported_items', { count: mappedItems.length }),
        severity: 'success'
      })
    } catch (error) {
      setSnackbar({
        open: true,
        message: t('import_failed'),
        severity: 'error'
      })
    }
  }

  const handleAddOrderItem = useCallback(() => {
    setOrderItems(prev => [
      ...prev,
      {
        tempId: `temp-${Date.now()}-${Math.random()}`, // Add unique temporary ID
        ingredientId: '',
        quantity: 1,
        unitPrice: 0,
        totalPrice: 0,
        notes: ''
      }
    ])
  }, [])

  // Get ingredients filtered by selected supplier (memoized to prevent re-renders)
  const filteredIngredients = useMemo(() => {
    if (!newOrder.supplierId) return []
    const selectedSupplier = suppliers.find(s => s.id === newOrder.supplierId)
    if (!selectedSupplier) return []

    return ingredients.filter(ingredient => ingredient.supplier === selectedSupplier.name)
  }, [newOrder.supplierId, suppliers, ingredients])

  const handleUpdateOrderItem = useCallback((tempId: string, field: keyof SupplierOrderItem, value: any) => {
    setOrderItems(prev =>
      prev.map(item => {
        if (item.tempId !== tempId) return item

        const updatedItem = { ...item, [field]: value }

        // Recalculate total price for this item
        if (field === 'quantity' || field === 'unitPrice') {
          updatedItem.totalPrice = updatedItem.quantity * updatedItem.unitPrice
        }

        return updatedItem
      })
    )

    // Update total amount in next effect
  }, [])

  // Effect to update total amount when order items change
  useEffect(() => {
    const totalAmount = orderItems.reduce((sum, item) => {
      const ingredient = ingredients.find(i => i.id === item.ingredientId)
      if (ingredient?.orderByPackage && ingredient?.unitsPerPackage && ingredient.unitsPerPackage > 1) {
        // If ordering by package, multiply by units per package
        return sum + item.totalPrice * ingredient.unitsPerPackage
      }
      return sum + item.totalPrice
    }, 0)
    setNewOrder(prev => ({ ...prev, totalAmount }))
  }, [orderItems, ingredients])

  const handleRemoveOrderItem = useCallback((tempId: string) => {
    setOrderItems(prev => prev.filter(item => item.tempId !== tempId))
  }, [])

  const handleSubmitOrder = async () => {
    try {
      // Remove tempId before submitting
      const cleanItems = orderItems.map(({ tempId, ...item }) => item)
      const orderData = { ...newOrder, items: cleanItems }

      if (editingOrder) {
        await supplierOrdersService.update(editingOrder.id, orderData)
        setSnackbar({ open: true, message: 'Supplier order updated successfully', severity: 'success' })
      } else {
        await supplierOrdersService.create(orderData as Omit<SupplierOrder, 'id' | 'orderNumber' | 'createdAt' | 'updatedAt'>)
        setSnackbar({ open: true, message: 'Supplier order created successfully', severity: 'success' })
      }
      handleCloseDialog()
      loadOrders()
    } catch (err) {
      setSnackbar({
        open: true,
        message: err instanceof Error ? err.message : 'Failed to save supplier order',
        severity: 'error'
      })
    }
  }

  const handleUpdateStatus = async (orderId: string, status: SupplierOrder['status']) => {
    try {
      await supplierOrdersService.updateStatus(orderId, status)
      setSnackbar({ open: true, message: 'Order status updated successfully', severity: 'success' })
      loadOrders()
    } catch (err) {
      setSnackbar({
        open: true,
        message: err instanceof Error ? err.message : 'Failed to update order status',
        severity: 'error'
      })
    }
  }

  const handleDeleteOrder = async (orderId: string) => {
    if (window.confirm('Are you sure you want to delete this order?')) {
      try {
        await supplierOrdersService.delete(orderId)
        setSnackbar({ open: true, message: 'Order deleted successfully', severity: 'success' })
        loadOrders()
      } catch (err) {
        setSnackbar({
          open: true,
          message: err instanceof Error ? err.message : 'Failed to delete order',
          severity: 'error'
        })
      }
    }
  }

  const handleGenerateAutoOrders = async () => {
    try {
      setLoading(true)
      const autoOrders = await supplierOrdersService.generateAutoOrders()
      setSnackbar({
        open: true,
        message: `Generated ${autoOrders.length} automatic orders based on low stock`,
        severity: 'success'
      })
      loadOrders()
    } catch (err) {
      setSnackbar({
        open: true,
        message: err instanceof Error ? err.message : 'Failed to generate auto orders',
        severity: 'error'
      })
    } finally {
      setLoading(false)
    }
  }

  const ordersNeedingAttention = orders.filter(order => {
    const now = new Date()
    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000)

    // Only flag as needing attention if:
    // 1. Delivery is overdue by more than 1 day AND not delivered/cancelled
    // 2. OR submitted orders older than 7 days
    return (order.expectedDeliveryDate && order.expectedDeliveryDate < oneDayAgo && !['delivered', 'cancelled'].includes(order.status)) || (order.status === 'submitted' && order.submittedDate && (now.getTime() - order.submittedDate.getTime()) / (1000 * 60 * 60 * 24) > 7)
  })

  // Sorting logic
  const handleRequestSort = (property: OrderBy) => {
    const isAsc = orderBy === property && orderDirection === 'asc'
    setOrderDirection(isAsc ? 'desc' : 'asc')
    setOrderBy(property)
  }

  const sortedOrders = useMemo(() => {
    const comparator = (a: SupplierOrder, b: SupplierOrder) => {
      let aValue: any
      let bValue: any

      switch (orderBy) {
        case 'orderNumber':
          aValue = a.orderNumber
          bValue = b.orderNumber
          break
        case 'supplier':
          aValue = a.supplier?.name || ''
          bValue = b.supplier?.name || ''
          break
        case 'totalAmount':
          aValue = a.totalAmount
          bValue = b.totalAmount
          break
        case 'status':
          aValue = a.status
          bValue = b.status
          break
        case 'priority':
          const priorityOrder = { urgent: 4, high: 3, medium: 2, low: 1 }
          aValue = priorityOrder[a.priority]
          bValue = priorityOrder[b.priority]
          break
        case 'orderDate':
          aValue = a.orderDate.getTime()
          bValue = b.orderDate.getTime()
          break
        case 'expectedDeliveryDate':
          aValue = a.expectedDeliveryDate?.getTime() || 0
          bValue = b.expectedDeliveryDate?.getTime() || 0
          break
        default:
          return 0
      }

      if (bValue < aValue) {
        return orderDirection === 'desc' ? -1 : 1
      }
      if (bValue > aValue) {
        return orderDirection === 'desc' ? 1 : -1
      }
      return 0
    }

    return [...orders].sort(comparator)
  }, [orders, orderBy, orderDirection])

  // Filter orders based on search query
  const filteredOrders = useMemo(() => {
    if (!searchQuery.trim()) return sortedOrders

    const query = searchQuery.toLowerCase()
    return sortedOrders.filter(order => {
      return order.orderNumber.toLowerCase().includes(query) || order.supplier?.name.toLowerCase().includes(query) || order.status.toLowerCase().includes(query) || order.priority.toLowerCase().includes(query) || order.notes?.toLowerCase().includes(query) || order.items.some(item => item.ingredient?.name.toLowerCase().includes(query))
    })
  }, [sortedOrders, searchQuery])

  // Calculate suppliers without open orders
  const suppliersWithoutOpenOrders = useMemo(() => {
    const suppliersWithOpenOrders = new Set(orders.filter(order => ['draft', 'submitted'].includes(order.status)).map(order => order.supplierId))

    return suppliers.filter(supplier => !suppliersWithOpenOrders.has(supplier.id))
  }, [suppliers, orders])

  if (loading && orders.length === 0) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="400px">
        <CircularProgress />
      </Box>
    )
  }

  return (
    <Box>
      {/* Header */}
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3} flexDirection={isRtl ? 'row-reverse' : 'row'}>
        <Typography variant="h4" component="h1" sx={{ textAlign: isRtl ? 'right' : 'left' }}>
          {t('supplier_orders')}
        </Typography>
        <Stack direction={isRtl ? 'row-reverse' : 'row'} spacing={2}>
          <Button variant="outlined" startIcon={<UploadIcon />} onClick={handleImportClick}>
            {t('import_from_file')}
          </Button>
          <Button variant="outlined" startIcon={<AutoOrderIcon />} onClick={handleGenerateAutoOrders} disabled={loading}>
            {t('generate_auto_orders')}
          </Button>
          <Button variant="contained" startIcon={<AddIcon />} onClick={() => handleOpenDialog()}>
            {t('new_order')}
          </Button>
        </Stack>
      </Box>

      {/* Summary Cards */}
      <Grid container spacing={3} mb={3} direction={isRtl ? 'row-reverse' : 'row'} justifyContent={isRtl ? 'flex-end' : 'flex-start'}>
        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent sx={{ textAlign: isRtl ? 'right' : 'left', display: 'flex', flexDirection: 'column', alignItems: isRtl ? 'flex-end' : 'flex-start' }}>
              <Box display="flex" alignItems="center" flexDirection={isRtl ? 'row-reverse' : 'row'}>
                <OrderIcon color="primary" sx={{ marginInlineEnd: 1 }} />
                <Box>
                  <Typography variant="h6" sx={theme => ({ color: theme.palette.mode === 'dark' ? theme.palette.primary.main : theme.palette.text.primary, fontWeight: 700 })}>
                    {orders.length}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {t('total_orders')}
                  </Typography>
                </Box>
              </Box>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent sx={{ textAlign: isRtl ? 'right' : 'left', display: 'flex', flexDirection: 'column', alignItems: isRtl ? 'flex-end' : 'flex-start' }}>
              <Box display="flex" alignItems="center" flexDirection={isRtl ? 'row-reverse' : 'row'}>
                <ScheduleIcon color="warning" sx={{ marginInlineEnd: 1 }} />
                <Box>
                  <Typography variant="h6" sx={theme => ({ color: theme.palette.mode === 'dark' ? theme.palette.primary.main : theme.palette.text.primary, fontWeight: 700 })}>
                    {orders.filter(o => o.status === 'submitted' || o.status === 'confirmed').length}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {t('pending_orders')}
                  </Typography>
                </Box>
              </Box>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent sx={{ textAlign: isRtl ? 'right' : 'left', display: 'flex', flexDirection: 'column', alignItems: isRtl ? 'flex-end' : 'flex-start' }}>
              <Box display="flex" alignItems="center" flexDirection={isRtl ? 'row-reverse' : 'row'}>
                <WarningIcon color="error" sx={{ marginInlineEnd: 1 }} />
                <Box>
                  <Typography variant="h6" sx={theme => ({ color: theme.palette.mode === 'dark' ? theme.palette.primary.main : theme.palette.text.primary, fontWeight: 700 })}>
                    {ordersNeedingAttention.length}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {t('need_attention')}
                  </Typography>
                </Box>
              </Box>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent sx={{ textAlign: isRtl ? 'right' : 'left', display: 'flex', flexDirection: 'column', alignItems: isRtl ? 'flex-end' : 'flex-start' }}>
              <Box display="flex" alignItems="center" flexDirection={isRtl ? 'row-reverse' : 'row'}>
                <CheckIcon color="success" sx={{ marginInlineEnd: 1 }} />
                <Box>
                  <Typography variant="h6" sx={theme => ({ color: theme.palette.mode === 'dark' ? theme.palette.primary.main : theme.palette.text.primary, fontWeight: 700 })}>
                    {orders.filter(o => o.status === 'delivered').length}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {t('delivered_text')}
                  </Typography>
                </Box>
              </Box>
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {/* Orders that need attention */}
      {ordersNeedingAttention.length > 0 && (
        <Card sx={{ mb: 3 }}>
          <CardContent>
            <Typography variant="h6" gutterBottom color="error">
              {t('orders_needing_attention')}
            </Typography>
            <List>
              {ordersNeedingAttention.map(order => (
                <ListItem key={order.id}>
                  <ListItemText primary={`${order.orderNumber} - ${order.supplier?.name}`} secondary={order.expectedDeliveryDate && order.expectedDeliveryDate < new Date(new Date().getTime() - 24 * 60 * 60 * 1000) ? t('overdue_delivery_expected', { date: format(order.expectedDeliveryDate, 'MMM dd, yyyy') }) : order.status === 'submitted' && order.submittedDate ? t('submitted_days_ago', { count: Math.floor((new Date().getTime() - order.submittedDate.getTime()) / (1000 * 60 * 60 * 24)) }) : t('needs_attention')} />
                  <ListItemSecondaryAction>
                    <IconButton onClick={() => handleOpenDialog(order)}>
                      <EditIcon />
                    </IconButton>
                  </ListItemSecondaryAction>
                </ListItem>
              ))}
            </List>
          </CardContent>
        </Card>
      )}

      {/* Suppliers without open orders */}
      {suppliersWithoutOpenOrders.length > 0 && (
        <Box sx={{ mb: 2 }}>
          {!expandedSuppliersSection ? (
            <Button variant="outlined" size="small" startIcon={<OrderIcon />} endIcon={<ExpandMoreIcon />} onClick={() => setExpandedSuppliersSection(true)} sx={{ textTransform: 'none' }}>
              {t('suppliers_without_open_orders')} ({suppliersWithoutOpenOrders.length})
            </Button>
          ) : (
            <Card>
              <CardContent>
                <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexDirection: isRtl ? 'row-reverse' : 'row', mb: 1 }}>
                  <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', flexDirection: isRtl ? 'row-reverse' : 'row' }}>
                    <OrderIcon sx={{ marginInlineEnd: 1 }} />
                    {t('suppliers_without_open_orders')}
                  </Typography>
                  <IconButton size="small" onClick={() => setExpandedSuppliersSection(false)}>
                    <ExpandLessIcon />
                  </IconButton>
                </Box>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                  {t('suppliers_without_open_orders_desc')}
                </Typography>
                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                  {suppliersWithoutOpenOrders.map(supplier => (
                    <Chip
                      key={supplier.id}
                      label={supplier.name}
                      variant="outlined"
                      onClick={() => {
                        setNewOrder({
                          supplierId: supplier.id,
                          items: [],
                          totalAmount: 0,
                          status: 'draft',
                          priority: 'medium',
                          orderDate: new Date(),
                          autoGenerated: false,
                          notes: ''
                        })
                        setOrderItems([])
                        handleOpenDialog()
                      }}
                      sx={{ cursor: 'pointer' }}
                    />
                  ))}
                </Box>
              </CardContent>
            </Card>
          )}
        </Box>
      )}

      {/* Error handling */}
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}

      {/* Orders Table */}
      <Card>
        <CardContent>
          {/* Search Bar */}
          <Box sx={{ mb: 2 }}>
            <TextField
              fullWidth
              size="small"
              placeholder={t('search_orders')}
              value={searchQuery}
              onChange={e => setSearchQuery(e.target.value)}
              InputProps={{
                startAdornment: <SearchIcon sx={{ mr: 1, color: 'text.secondary' }} />
              }}
            />
          </Box>

          <TableContainer component={Paper} dir={isRtl ? 'rtl' : 'ltr'}>
            <Table dir={isRtl ? 'rtl' : 'ltr'}>
              <TableHead>
                <TableRow>
                  <TableCell>
                    <TableSortLabel active={orderBy === 'orderNumber'} direction={orderBy === 'orderNumber' ? orderDirection : 'asc'} onClick={() => handleRequestSort('orderNumber')}>
                      {t('order_number')}
                    </TableSortLabel>
                  </TableCell>
                  <TableCell>
                    <TableSortLabel active={orderBy === 'supplier'} direction={orderBy === 'supplier' ? orderDirection : 'asc'} onClick={() => handleRequestSort('supplier')}>
                      {t('supplier_label')}
                    </TableSortLabel>
                  </TableCell>
                  <TableCell>{t('items')}</TableCell>
                  <TableCell sx={{ textAlign: isRtl ? 'start' : 'end' }}>
                    <TableSortLabel active={orderBy === 'totalAmount'} direction={orderBy === 'totalAmount' ? orderDirection : 'asc'} onClick={() => handleRequestSort('totalAmount')}>
                      {t('total_amount')}
                    </TableSortLabel>
                  </TableCell>
                  <TableCell>
                    <TableSortLabel active={orderBy === 'status'} direction={orderBy === 'status' ? orderDirection : 'asc'} onClick={() => handleRequestSort('status')}>
                      {t('status')}
                    </TableSortLabel>
                  </TableCell>
                  <TableCell>
                    <TableSortLabel active={orderBy === 'priority'} direction={orderBy === 'priority' ? orderDirection : 'asc'} onClick={() => handleRequestSort('priority')}>
                      {t('priority')}
                    </TableSortLabel>
                  </TableCell>
                  <TableCell>
                    <TableSortLabel active={orderBy === 'orderDate'} direction={orderBy === 'orderDate' ? orderDirection : 'asc'} onClick={() => handleRequestSort('orderDate')}>
                      {t('order_date')}
                    </TableSortLabel>
                  </TableCell>
                  <TableCell>
                    <TableSortLabel active={orderBy === 'expectedDeliveryDate'} direction={orderBy === 'expectedDeliveryDate' ? orderDirection : 'asc'} onClick={() => handleRequestSort('expectedDeliveryDate')}>
                      {t('expected_delivery')}
                    </TableSortLabel>
                  </TableCell>
                  <TableCell sx={{ textAlign: isRtl ? 'start' : 'end' }}>{t('actions')}</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {filteredOrders.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={9} align="center" sx={{ py: 4 }}>
                      <Typography variant="body1" color="text.secondary">
                        {searchQuery ? t('no_orders_match_search') : t('no_orders_found')}
                      </Typography>
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredOrders.map(order => (
                    <TableRow key={order.id}>
                      <TableCell>
                        <Box display="flex" alignItems="center" flexDirection={isRtl ? 'row-reverse' : 'row'}>
                          {order.autoGenerated && <AutoOrderIcon color="info" sx={{ marginInlineEnd: 1, fontSize: 16 }} />}
                          {order.orderNumber}
                        </Box>
                      </TableCell>
                      <TableCell>{order.supplier?.name || t('unknown')}</TableCell>
                      <TableCell>
                        {order.items.length} {t('items')}
                      </TableCell>
                      <TableCell sx={{ textAlign: isRtl ? 'start' : 'end' }}>{formatCurrency(order.totalAmount)}</TableCell>
                      <TableCell>
                        <FormControl size="small" sx={{ minWidth: 120 }}>
                          <Select
                            value={order.status}
                            onChange={e => handleUpdateStatus(order.id, e.target.value as SupplierOrder['status'])}
                            variant="outlined"
                            sx={{
                              '& .MuiSelect-select': {
                                padding: '4px 8px',
                                backgroundColor: order.status === 'draft' ? '#f5f5f5' : order.status === 'submitted' ? '#e3f2fd' : order.status === 'confirmed' ? '#e8f5e8' : order.status === 'shipped' ? '#fff3e0' : order.status === 'delivered' ? '#e8f5e8' : order.status === 'cancelled' ? '#ffebee' : '#f5f5f5',
                                fontSize: '0.75rem',
                                fontWeight: 500
                              }
                            }}
                          >
                            {ORDER_STATUSES.map(status => (
                              <MuiMenuItem key={status} value={status}>
                                <Chip label={t(status)} color={getStatusColor(status)} size="small" />
                              </MuiMenuItem>
                            ))}
                          </Select>
                        </FormControl>
                      </TableCell>
                      <TableCell>
                        <Chip label={order.priority} color={getPriorityColor(order.priority)} size="small" />
                      </TableCell>
                      <TableCell>{format(order.orderDate, 'MMM dd, yyyy')}</TableCell>
                      <TableCell>{order.expectedDeliveryDate ? format(order.expectedDeliveryDate, 'MMM dd, yyyy') : '-'}</TableCell>
                      <TableCell sx={{ textAlign: isRtl ? 'start' : 'end' }}>
                        <IconButton onClick={() => handleOpenDialog(order)} size="small" color="primary" title={t('edit_order')} sx={{ marginInlineEnd: 1 }}>
                          <EditIcon />
                        </IconButton>
                        <IconButton onClick={() => handleDeleteOrder(order.id)} size="small" color="error" title={t('delete_order')}>
                          <DeleteIcon />
                        </IconButton>
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </TableContainer>
        </CardContent>
      </Card>

      {/* Create/Edit Order Dialog */}
      <Dialog open={openDialog} onClose={handleCloseDialog} maxWidth="md" fullWidth>
        <DialogTitle>{editingOrder ? t('edit_supplier_order') : t('create_new_supplier_order')}</DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12} sm={6}>
              <Autocomplete
                options={suppliers}
                getOptionLabel={option => option.name}
                value={suppliers.find(s => s.id === newOrder.supplierId) || null}
                onChange={(_, supplier) => {
                  setNewOrder({ ...newOrder, supplierId: supplier?.id || '', totalAmount: 0 })
                  // Clear existing order items when supplier changes
                  setOrderItems([])
                }}
                renderInput={params => <TextField {...params} label={t('supplier_label')} fullWidth required />}
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth>
                <InputLabel>{t('priority')}</InputLabel>
                <Select value={newOrder.priority || 'medium'} onChange={e => setNewOrder({ ...newOrder, priority: e.target.value as SupplierOrder['priority'] })} label={t('priority')}>
                  {ORDER_PRIORITIES.map(priority => (
                    <MuiMenuItem key={priority} value={priority}>
                      {priority.charAt(0).toUpperCase() + priority.slice(1)}
                    </MuiMenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth>
                <InputLabel>{t('status')}</InputLabel>
                <Select value={newOrder.status || 'draft'} onChange={e => setNewOrder({ ...newOrder, status: e.target.value as SupplierOrder['status'] })} label={t('status')}>
                  {ORDER_STATUSES.map(status => (
                    <MuiMenuItem key={status} value={status}>
                      <Chip label={t(status)} color={getStatusColor(status)} size="small" />
                    </MuiMenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                label={t('order_date')}
                type="date"
                value={newOrder.orderDate ? format(newOrder.orderDate, 'yyyy-MM-dd') : format(new Date(), 'yyyy-MM-dd')}
                onChange={e =>
                  setNewOrder({
                    ...newOrder,
                    orderDate: e.target.value ? new Date(e.target.value) : new Date()
                  })
                }
                fullWidth
                InputLabelProps={{ shrink: true }}
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                label={t('expected_delivery')}
                type="date"
                value={newOrder.expectedDeliveryDate ? format(newOrder.expectedDeliveryDate, 'yyyy-MM-dd') : ''}
                onChange={e =>
                  setNewOrder({
                    ...newOrder,
                    expectedDeliveryDate: e.target.value ? new Date(e.target.value) : undefined
                  })
                }
                fullWidth
                InputLabelProps={{ shrink: true }}
              />
            </Grid>
            <Grid item xs={12}>
              <TextField label={t('notes')} value={newOrder.notes || ''} onChange={e => setNewOrder({ ...newOrder, notes: e.target.value })} multiline rows={2} fullWidth />
            </Grid>
          </Grid>

          <Divider sx={{ my: 2 }} />

          <Box display="flex" justifyContent="space-between" alignItems="center" mb={2} flexDirection={isRtl ? 'row-reverse' : 'row'}>
            <Typography variant="h6" sx={{ textAlign: isRtl ? 'right' : 'left' }}>
              {t('order_items')}
            </Typography>
            <Button startIcon={<AddIcon />} onClick={handleAddOrderItem} disabled={!newOrder.supplierId}>
              {t('add_item')}
            </Button>
          </Box>

          {!newOrder.supplierId && (
            <Alert severity="info" sx={{ mb: 2 }}>
              {t('select_supplier_first')}
            </Alert>
          )}

          {newOrder.supplierId && filteredIngredients.length === 0 && (
            <Alert severity="warning" sx={{ mb: 2 }}>
              {t('no_ingredients_for_supplier')}
            </Alert>
          )}

          {orderItems.map(item => {
            const selectedIngredient = filteredIngredients.find(i => i.id === item.ingredientId)
            console.log('Selected ingredient:', selectedIngredient)
            const hasPackaging = selectedIngredient?.orderByPackage && selectedIngredient?.unitsPerPackage && selectedIngredient.unitsPerPackage > 1
            const packageInfo = hasPackaging ? `${selectedIngredient.unitsPerPackage} ${selectedIngredient.unit} per ${selectedIngredient.packageType || 'package'}` : ''
            const totalUnits = hasPackaging ? item.quantity * (selectedIngredient?.unitsPerPackage || 1) : item.quantity

            return (
              <Box key={item.tempId} sx={{ mb: 3 }}>
                <Grid container spacing={2} alignItems="flex-start">
                  <Grid item xs={12} sm={4}>
                    <Autocomplete
                      options={filteredIngredients}
                      getOptionLabel={option => {
                        if (option.orderByPackage && option.unitsPerPackage && option.unitsPerPackage > 1) {
                          return `${option.name} (${option.unitsPerPackage} ${option.unit}/${option.packageType || 'package'})`
                        }
                        return option.name
                      }}
                      value={filteredIngredients.find(i => i.id === item.ingredientId) || null}
                      onChange={(_, ingredient) => {
                        handleUpdateOrderItem(item.tempId, 'ingredientId', ingredient?.id || '')
                        if (ingredient) {
                          handleUpdateOrderItem(item.tempId, 'unitPrice', ingredient.costPerUnit)
                        }
                      }}
                      renderInput={params => <TextField {...params} label={t('ingredient')} size="small" />}
                      disabled={!newOrder.supplierId}
                      noOptionsText={!newOrder.supplierId ? t('select_supplier_first') : t('no_ingredients_for_supplier')}
                      isOptionEqualToValue={(option, value) => option.id === value.id}
                    />
                  </Grid>
                  <Grid item xs={6} sm={2}>
                    <TextField label={hasPackaging ? `${t('quantity')} (${selectedIngredient?.packageType || 'packages'})` : t('quantity')} type="number" value={item.quantity} onChange={e => handleUpdateOrderItem(item.tempId, 'quantity', Number(e.target.value))} size="small" fullWidth helperText={hasPackaging ? `${totalUnits} ${selectedIngredient?.unit} total` : ''} />
                  </Grid>
                  <Grid item xs={6} sm={2}>
                    <TextField label={hasPackaging ? `${t('unit_cost')}/${selectedIngredient?.unit}` : t('unit_cost')} type="number" value={item.unitPrice} onChange={e => handleUpdateOrderItem(item.tempId, 'unitPrice', Number(e.target.value))} size="small" fullWidth />
                  </Grid>
                  <Grid item xs={6} sm={2}>
                    <TextField label={t('total')} value={formatCurrency(hasPackaging ? item.totalPrice * (selectedIngredient?.unitsPerPackage || 1) : item.totalPrice)} size="small" fullWidth disabled />
                  </Grid>
                  <Grid item xs={6} sm={2} sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: '56px' }}>
                    <IconButton onClick={() => handleRemoveOrderItem(item.tempId)} color="error">
                      <DeleteIcon />
                    </IconButton>
                  </Grid>
                </Grid>
                {packageInfo && (
                  <Typography variant="caption" color="textSecondary" sx={{ ml: 0, mt: 0.5, display: 'block' }}>
                    {packageInfo}
                  </Typography>
                )}
              </Box>
            )
          })}

          <Box mt={2} textAlign={isRtl ? 'left' : 'right'}>
            <Typography variant="h6">
              {t('total_amount')}: {formatCurrency(newOrder.totalAmount || 0)}
            </Typography>
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>{t('cancel')}</Button>
          <Button onClick={handleSubmitOrder} variant="contained" disabled={!newOrder.supplierId || orderItems.length === 0}>
            {editingOrder ? t('update_order') : t('create_order')}
          </Button>
        </DialogActions>
      </Dialog>

      {/* Snackbar for notifications */}
      <Snackbar open={snackbar.open} autoHideDuration={6000} onClose={() => setSnackbar({ ...snackbar, open: false })}>
        <Alert onClose={() => setSnackbar({ ...snackbar, open: false })} severity={snackbar.severity}>
          {snackbar.message}
        </Alert>
      </Snackbar>

      {/* Import Dialog */}
      <Dialog open={openImportDialog} onClose={() => setOpenImportDialog(false)} maxWidth="md" fullWidth>
        <DialogTitle>{t('import_supplier_order')}</DialogTitle>
        <DialogContent>
          <Alert severity="info" sx={{ mb: 2 }}>
            {t('import_instructions')}
          </Alert>

          {importData.length > 0 && (
            <>
              <Typography variant="h6" sx={{ mb: 2 }}>
                {t('map_columns')}
              </Typography>

              <Grid container spacing={2}>
                <Grid item xs={12}>
                  <Autocomplete options={suppliers} getOptionLabel={option => option.name} value={importMapping.supplier || null} onChange={(_, supplier) => setImportMapping({ ...importMapping, supplier: supplier || undefined })} renderInput={params => <TextField {...params} label={t('select_supplier')} required />} />
                </Grid>

                {importData.length > 0 && (
                  <>
                    <Grid item xs={12} sm={4}>
                      <FormControl fullWidth>
                        <InputLabel>{t('item_name_column')}</InputLabel>
                        <Select value={importMapping.itemNameColumn || ''} onChange={e => setImportMapping({ ...importMapping, itemNameColumn: e.target.value })} label={t('item_name_column')}>
                          {Object.keys(importData[0]).map(column => (
                            <MuiMenuItem key={column} value={column}>
                              {column}
                            </MuiMenuItem>
                          ))}
                        </Select>
                      </FormControl>
                    </Grid>

                    <Grid item xs={12} sm={4}>
                      <FormControl fullWidth>
                        <InputLabel>{t('quantity_column')}</InputLabel>
                        <Select value={importMapping.quantityColumn || ''} onChange={e => setImportMapping({ ...importMapping, quantityColumn: e.target.value })} label={t('quantity_column')}>
                          {Object.keys(importData[0]).map(column => (
                            <MuiMenuItem key={column} value={column}>
                              {column}
                            </MuiMenuItem>
                          ))}
                        </Select>
                      </FormControl>
                    </Grid>

                    <Grid item xs={12} sm={4}>
                      <FormControl fullWidth>
                        <InputLabel>{t('unit_price_column')}</InputLabel>
                        <Select value={importMapping.unitPriceColumn || ''} onChange={e => setImportMapping({ ...importMapping, unitPriceColumn: e.target.value })} label={t('unit_price_column')}>
                          {Object.keys(importData[0]).map(column => (
                            <MuiMenuItem key={column} value={column}>
                              {column}
                            </MuiMenuItem>
                          ))}
                        </Select>
                      </FormControl>
                    </Grid>
                  </>
                )}
              </Grid>

              {/* Preview */}
              <Typography variant="h6" sx={{ mt: 3, mb: 1 }}>
                {t('preview')}
              </Typography>
              <TableContainer component={Paper} sx={{ maxHeight: 300 }}>
                <Table size="small">
                  <TableHead>
                    <TableRow>
                      <TableCell>{t('item_name')}</TableCell>
                      <TableCell>{t('quantity')}</TableCell>
                      <TableCell>{t('unit_price')}</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {importData.slice(0, 5).map((row, index) => (
                      <TableRow key={index}>
                        <TableCell>{importMapping.itemNameColumn ? row[importMapping.itemNameColumn] : '-'}</TableCell>
                        <TableCell>{importMapping.quantityColumn ? row[importMapping.quantityColumn] : '-'}</TableCell>
                        <TableCell>{importMapping.unitPriceColumn ? row[importMapping.unitPriceColumn] : '-'}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
              {importData.length > 5 && (
                <Typography variant="caption" color="text.secondary" sx={{ mt: 1 }}>
                  {t('showing_first_5_rows')}
                </Typography>
              )}
            </>
          )}
        </DialogContent>
        <DialogActions>
          <Button
            onClick={() => {
              setOpenImportDialog(false)
              setImportData([])
              setImportMapping({})
            }}
          >
            {t('cancel')}
          </Button>
          <Button onClick={handleImportMapping} variant="contained" disabled={!importMapping.supplier || !importMapping.itemNameColumn || !importMapping.quantityColumn || !importMapping.unitPriceColumn}>
            {t('import')}
          </Button>
        </DialogActions>
      </Dialog>

      {/* File Input */}
      <input type="file" ref={fileInputRef} accept=".csv,.xls,.xlsx" style={{ display: 'none' }} onChange={handleFileImport} />
    </Box>
  )
}
